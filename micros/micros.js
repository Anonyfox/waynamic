// Generated by CoffeeScript 1.7.1
(function() {
  var Micros, async, coffee, decompress, generate_key, process_inner_chain, _,
    __slice = [].slice;

  Micros = (typeof exports !== "undefined" && exports !== null) && exports || (this.Micros = {});

  coffee = require('coffee-script');

  require('coffee-script/register');

  _ = require('underscore');

  async = require('async');

  decompress = function(arr) {
    if (arr instanceof Array && arr.length === 1 && arr[0] instanceof Array) {
      arr = arr[0];
    }
    return arr;
  };

  generate_key = function() {
    return (new Date).valueOf() + '' + Math.floor((Math.random()) * Math.pow(10, 8));
  };

  process_inner_chain = function(fn) {
    var chain;
    chain = fn();
    if ((chain != null ? chain._type : void 0) === Micros.MicroService) {
      chain = chain(function() {
        return new Micros.Chain;
      });
    }
    if ((chain != null ? chain._type : void 0) === Micros.Broadcast) {
      chain = new Micros.Chain(chain);
    }
    return chain;
  };

  Micros.MicroService = function(name) {
    var cwd, gather_call, meta, ms, timeout;
    ms = function() {
      var chain, fn, method, params, service, _i;
      params = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), fn = arguments[_i++];
      params = decompress(params);
      if (this instanceof String) {
        method = this.toString();
      }
      if (typeof fn !== 'function') {
        params.push(fn);
        fn = function() {
          return new Micros.Chain;
        };
      }
      service = {
        name: ms.$module_name
      };
      if (params.length > 0) {
        service.params = params;
      }
      if (method != null) {
        service.method = method;
      }
      service.api = ms.$config.api;
      service.port = ms.$config.port;
      chain = process_inner_chain(fn);
      chain.value.push(service);
      return chain;
    };
    if (!/^micros-(.*)/.exec(name)) {
      ms.$module_name = 'micros-' + name;
    }
    ms.$cache = {};
    ms.$gathers = {};
    ms.$timeouts = [];
    try {
      cwd = process.cwd();
      ms.$config = require("" + cwd + "/node_modules/" + ms.$module_name + "/config.json");
      if (ms.$config['timeout'] == null) {
        ms.$config.timeout = 10 * 1000;
      }
      meta = require("" + cwd + "/node_modules/" + ms.$module_name + "/package.json");
      ms.$module_name = meta.name;
      if (meta.name = /^micros-(.*)/.exec(meta.name)) {
        ms.$name = meta.name[1];
      }
      ms.$version = meta.version;
      ms.$description = meta.description;
    } catch (_error) {}
    ms.$install = function(runtime) {
      var key, value, _ref, _results;
      ms.$runtime = runtime;
      _ref = ms.$runtime;
      _results = [];
      for (key in _ref) {
        value = _ref[key];
        ms[key] = (function(method) {
          return function() {
            var fn, params, _i;
            params = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), fn = arguments[_i++];
            params = decompress(params);
            return ms.call(new String(method), params, fn);
          };
        })(key);
        ms[key]._type = Micros.MicroService;
        _results.push(ms[key]._this = this);
      }
      return _results;
    };
    ms.$map = ms.$install;
    ms.$next = function() {
      var chain, http, i, link, message, next, options, path, req, request, res, util, _i, _j, _len, _results;
      req = 3 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 2) : (_i = 0, []), res = arguments[_i++], chain = arguments[_i++];
      req = decompress(req);
      if (chain.length === 0) {
        return;
      }
      util = require('util');
      next = chain.pop();
      if (util.isArray(next)) {
        if ((_.last(chain)) != null) {
          chain[chain.length - 1].gather = {
            key: generate_key(),
            services: next.length
          };
        }
      } else {
        next = [next];
      }
      _results = [];
      for (i = _j = 0, _len = next.length; _j < _len; i = ++_j) {
        link = next[i];
        path = chain;
        if (util.isArray(link)) {
          path = path.concat(link);
          link = path.pop();
        }
        message = {
          request: req[i],
          response: res,
          sender: ms.$module_name,
          chain: path
        };
        if (message.request != null) {
          message.request = _.last(req);
        }
        if ((i + 1) === next.length && (req[i + 1] != null)) {
          message.request = _.rest(req, i);
        }
        if (link.params != null) {
          message.params = link.params;
        }
        if (link.gather != null) {
          message.gather = link.gather;
        }
        if (link.method != null) {
          message.method = link.method;
        }
        switch (link.api) {
          case 'http':
            http = require('http');
            options = {
              port: link.port
            };
            options.method = 'POST';
            if (message.method != null) {
              options.path = "/" + message.method;
            }
            options.headers = {
              'Content-Type': 'application/json'
            };
            request = http.request(options);
            request.write(JSON.stringify(message));
            _results.push(request.end());
            break;
          default:
            _results.push(void 0);
        }
      }
      return _results;
    };
    ms.$spawn = function(cb) {
      var error, exec;
      if (cb == null) {
        cb = function() {};
      }
      exec = require('child_process').exec;
      try {
        ms.$process = exec("" + __dirname + "/bin/wrapper.js " + ms.$module_name + " > " + ms.$module_name);
      } catch (_error) {
        error = _error;
        return setTimeout(cb, 0, error);
      }
      return setTimeout(cb, 0);
    };
    gather_call = function(key, message) {
      var stack;
      stack = [];
      ms.$gathers[key].next.previous = ms.$gathers[key].previous;
      stack.push(ms.$gathers[key].requests);
      stack.push(ms.$gathers[key].responses);
      stack.push(ms.$gathers[key].next);
      if (message.params != null) {
        stack = stack.concat(message.params);
      }
      if (message.method != null) {
        setTimeout(ms.$runtime[message.method].apply, 0, ms, stack);
      } else {
        setTimeout(ms.$runtime.apply, 0, ms, stack);
      }
      return delete ms.$gathers[key];
    };
    timeout = function(key, message) {
      if (ms.$gathers[key] != null) {
        gather_call(key, message);
        ms.$gather[key] = 'timeouted';
        return ms.$timeouts.push(key);
      }
    };
    ms.$clear = function() {
      var key, _i, _len, _ref;
      _ref = ms.$timeouts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        delete ms.$gather[key];
      }
      return ms.$timeouts = [];
    };
    ms.$call = function(message) {
      var key, next, stack;
      next = function() {
        var req, res, _i;
        req = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), res = arguments[_i++];
        return ms.$next.chain.call(ms, req, res, message.chain);
      };
      next.chain = message.chain;
      if (message.gather != null) {
        if (ms.$gather[key] === 'timeouted') {
          return;
        }
        key = message.gather.key;
        if (ms.$gathers[key] == null) {
          ms.$gathers[key] = {
            requests: [],
            responses: [],
            previous: [],
            services: message.gather.services,
            next: next
          };
          setTimeout(timeout, ms.$config.timeout, key, message);
        }
        ms.$gathers[key].lock = true;
        ms.$gathers[key].requests.push(message.request);
        ms.$gathers[key].responses.push(message.response);
        ms.$gathers[key].previous.push(message.sender);
        ms.$gathers[key].services -= 1;
        if (ms.$gathers[key].services === 0) {
          return gather_call(key, message);
        }
      } else {
        next.previous = message.sender;
        stack = [];
        stack.push(message.request);
        stack.push(message.response);
        stack.push(next);
        if (message.params != null) {
          stack = stack.concat(message.params);
        }
        if (message.method != null) {
          return setTimeout(ms.$runtime[message.method].apply, 0, ms, stack);
        } else {
          return setTimeout(ms.$runtime.apply, 0, ms, stack);
        }
      }
    };
    ms.$deamon = function() {
      var cluster;
      if ((ms.$config.clusters != null) && ms.$config.clusters > 1) {
        cluster = require('cluster');
        if (cluster.isMaster()) {
          process.title = "MicroService: " + ms.$module_name + " (" + ms.$version + ") [master]";
          _.times(ms.$config.clusters, cluster.fork);
          cluster.on('exit', function(worker, code, signal) {
            return console.log("Worker[" + worker.id + "]: '" + ms.$name + "' stopped!");
          });
          return cluster.on('online', function(worker) {
            return console.log("Worker[" + worker.id + "]: '" + ms.$name + "' started!");
          });
        } else {
          process.title = "MicroService: " + ms.$module_name + " (" + ms.$version + ") [slave]";
          process.on('SIGTERM', function() {
            return ms.$shutdown(function(error) {
              if (error) {
                return console.log(error);
              }
            });
          });
          return ms.$listen(function(error) {
            if (error) {
              return console.log(error);
            }
          });
        }
      } else {
        process.title = "MicroService: " + ms.$module_name + " (" + ms.$version + ")";
        process.on('SIGTERM', function() {
          return ms.$shutdown(function(error) {
            if (!error) {
              return console.log("MicroService: '" + ms.$name + "' stopped!");
            } else {
              return console.log(error);
            }
          });
        });
        return ms.$listen(function(error) {
          if (!error) {
            return console.log("MicroService: '" + ms.$name + "' started on port: " + ms.$config.port);
          } else {
            return console.log(error);
          }
        });
      }
    };
    ms.$listen = function(cb) {
      var app, express, http;
      if (cb == null) {
        cb = function() {};
      }
      ms.$interval = setInterval(ms.$clear, 1000 * 60 * 5);
      switch (ms.$config.api) {
        case 'http':
          express = require('express');
          app = express();
          app.use(express.json());
          app.post('/', function(req, res, next) {
            res.json(req.body);
            console.log('New Request!');
            return ms.$call(req.body);
          });
          app.post('/:method', function(req, res, next) {
            req.body.method = req.params['method'];
            console.log('New Request!');
            res.json(req.body);
            return ms.$call(req.body);
          });
          http = require('http');
          ms.$service = http.createServer(app);
          ms.$service.listen(ms.$config.port);
      }
      return setTimeout(cb, 0, null, ms.$service);
    };
    ms.$shutdown = function(cb) {
      var error;
      if (cb == null) {
        cb = function() {};
      }
      if (ms.$interval != null) {
        clearInterval(ms.$interval);
      }
      switch (ms.$config.api) {
        case 'http':
          try {
            ms.$service.close();
          } catch (_error) {
            error = _error;
            return setTimeout(cb, 0, error);
          }
      }
      return setTimeout(cb, 0);
    };
    ms._this = this;
    ms._type = Micros.MicroService;
    return ms;
  };

  Micros.Chain = function(chain) {
    var ch;
    ch = function(fn) {
      chain = process_inner_chain(fn);
      chain.value = chain.value.concat(ch.value);
      return chain;
    };
    ch.exec = function() {
      var init, reqres, service;
      init = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      init = decompress(init);
      reqres = init;
      reqres.push({});
      reqres.push(ch.value);
      service = new Micros.MicroService('router');
      return service.$next.apply(service, reqres);
    };
    ch.value = (chain != null ? chain._type : void 0) === Micros.MicroService ? process_inner_chain(function() {
      return chain;
    }).value : (chain != null ? chain._type : void 0) === Micros.Broadcast ? [chain.value] : (chain != null ? chain._type : void 0) === Micros.Chain || typeof chain === 'object' ? chain.value : typeof chain === 'function' ? process_inner_chain(chain).value : [];
    ch._this = this;
    ch._type = Micros.Chain;
    return ch;
  };

  Micros.Broadcast = function() {
    var bc, chains, chn;
    chains = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    bc = function(fn) {
      var chain;
      chain = new Micros.Chain(fn);
      chain.value = chain.value.concat([bc.value]);
      return chain;
    };
    bc.exec = function() {
      var init;
      init = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (new Micros.Chain(bc)).exec.apply(bc, init);
    };
    bc.value = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = chains.length; _i < _len; _i++) {
        chn = chains[_i];
        _results.push((new Micros.Chain(chn)).value);
      }
      return _results;
    })();
    bc._this = this;
    bc._type = Micros.Broadcast;
    return bc;
  };


  /*
    Chains:
       * Begin the chain at your desire
      new Chain -> f1 -> f2 -> f3 -> f4 -> f5
      new Chain f1 -> f2 -> f3 -> f4 -> f5
  
       * Defining Broadcasts and Akkumulators (Gathers)
      new Chain f1 -> f2 -> Broadcast(f3 -> f4, f3) -> f5
  
       * Include Chains in Chains
      inner_chain = new Chain -> f2 -> f3 -> f4
      new Chain f1 -> inner_chain -> f5
  
       * Use MicroService Methods to costimize your service and API
      new Chain -> f1 -> f2.method -> f3 -> f4
  
       * Use Parameters for better variation (works also with service methods)
      new Chain f1 3, -> f2.method -> f3.method 'msg', -> f4 -> f5
         * => is the first Parameter a String the value will be interpreted as Micro Service method
  
       * Alternative Parameter Syntax
      new Chain f1(3) -> f2.method -> f3.method('msg') -> f4 -> f5
   */


  /*
      Service Handler: req, res, params..., next
       * ´next´ stand for a function with additional informations
      next.chain      # further chain
      next.previous   # previous service
  
       * Call ´next´ with multiple request for different messages to send on each broadcast link
       * If there exist only one request object then all broadcast links will receive the same message
      next req1, req2, re3, ..., res      # Multiple Requests for Broadcast
      next req, res                       # Only one request for all Broadcast links
  
       * For a gather service (with gather key)
      (req[], res[], params..., next)     # `req` and `res` are arrays with all gathered requests and responses
      next.chain                          # The further chain (unchanged)
      next.previous                       # Previous services from broadcast (Array)
   */


  /*
     * A parsed chain in array notation
    chain = [
      {                               # Object that saves MicroService information
        name: ms.$module_name
      },
      [                               # Broadcast
        [                             # First broadcast link as inner Chain
          {                           # First MicroService from an inner Chain
            name: ms.$module_name,
            params: ['first', 'second', 'third']
          }
        ],
        [                             # Second broadcast link as inner Chain
          {                           # First MicroService from the second inner Chain
            name: ms.$module_name,
            method: 'action_handler'
          },
          {                           # Second MicroService from the second inner Chain
            name: ms.$module_name,
          }
        ]
      ],
      {                               # A Gather MicroService after a Broadcast
        name: ms.$module_name,
        api: 'http'
        port: 3030
      }
    ]
   */


  /*
     * Inter Communication Message (ICM)
    message = {
      request: {...}    # The Request Object with processing parameters
      response: {...}   # The Response Object with processing results
      chain: [...]      # The further chain
      sender: 'sender'  # The senders $module_name
      params: [...]     # As Array (optional)
      method: 'method'  # The MicroService method (optional)
      gather: {         # Used for Gather the same chain over multiple requests (optional)
        key: 'd6sd436'
        services: 5     # Service counter
      }
    }
   */


  /*
    Todo:
      - Abort, Timeout the chain after a broadcast (gather)
   */

}).call(this);
